package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/ioutil"
	"log"
	"os"
	"os/exec"
	"path/filepath"
	"strings"
	"text/template"
)

type Config struct {
	InFile    string
	OutFile   string
	UniqueID  string
	BuildTags string
	Vars      map[string]interface{}
}

func (c *Config) SetVar(v, x string) {
	l := len(x)
	if l > 1 && x[0] == '{' && x[l-1] == '}' {
		c.Vars[v] = strings.Split(x[1:l-1], ",")
	} else {
		c.Vars[v] = x
	}
}

func (c *Config) Set(opt string) (err error) {
	e := strings.Split(opt, "=")
	switch len(e) {
	case 2:
		c.SetVar(e[0], e[1])
	default:
		err = fmt.Errorf("bad define: " + opt)
	}
	return
}

func (c *Config) Get() interface{} { return c.Vars }

func (c *Config) String() string { return fmt.Sprintf("%v", c.Vars) }

func main() {
	c := &Config{}
	c.Vars = make(map[string]interface{})

	flag.StringVar(&c.OutFile, "o", "", "Output file (- for stdout)")
	flag.StringVar(&c.UniqueID, "id", "", "Unique name")
	flag.StringVar(&c.BuildTags, "tags", "", "Build tags for generated file.")
	flag.Var(c, "d", "Define variables in the form VAR=VALUE for use by template.")
	flag.Parse()

	if len(c.UniqueID) == 0 {
		fmt.Fprintf(os.Stderr, "%s: must specify -id\n", os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}

	if flag.NArg() != 1 {
		fmt.Fprintf(os.Stderr, "%s: missing template file name\n", os.Args[0])
		flag.PrintDefaults()
		os.Exit(1)
	}
	c.InFile = flag.Arg(0)

	contents, err := ioutil.ReadFile(c.InFile)

	// Try to find template give go path.
	if os.IsNotExist(err) && c.InFile[0] != '/' {
		dir := strings.ToLower(filepath.Dir(c.InFile))
		cmd := exec.Command("go", "list", "-f", "{{.Dir}}", dir)
		var b bytes.Buffer
		cmd.Stdout = &b
		err = cmd.Run()
		if err != nil {
			log.Fatalf("template not found: %s", c.InFile)
		}
		c.InFile = fmt.Sprintf("%s/%s", strings.TrimSpace(b.String()), filepath.Base(c.InFile))
		contents, err = ioutil.ReadFile(c.InFile)
	}

	if err != nil {
		log.Fatal(err)
	}

	// Create a new template and parse the letter into it.
	t := template.Must(template.New(c.InFile).Parse(string(contents)))

	t.Option("missingkey=error")

	c.Vars["ID"] = c.UniqueID
	c.Vars["TAGS"] = c.BuildTags

	w := new(bytes.Buffer)
	fmt.Fprintf(w, "// autogenerated: do not edit!\n")
	fmt.Fprintf(w, "// generated from gentemplate %v\n", os.Args)

	// Execute the template for each recipient.
	err = t.Execute(w, c.Vars)
	if err != nil {
		fmt.Println(err)
		os.Exit(1)
	}

	// gofmt result
	b := w.Bytes()
	b, err = format.Source(b)
	if err != nil {
		fmt.Printf("%s", w.Bytes())
		panic(err)
	}

	if c.OutFile != "-" {
		if c.OutFile == "" {
			base := strings.ToLower(filepath.Base(c.InFile))
			ext := filepath.Ext(base)
			c.OutFile = fmt.Sprintf("gentemplate_%s_%s.go", base[:len(base)-len(ext)],
				strings.ToLower(c.UniqueID))
		}
		err = ioutil.WriteFile(c.OutFile, b, 0666)
		if err != nil {
			log.Fatalf("can't write output: %v\n", err)
		}
	} else {
		fmt.Printf("%s", b)
	}
}
